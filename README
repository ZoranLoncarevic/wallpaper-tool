This is supposed to be a script for doing everything related
to desktop wallpaper. It is inspired by

https://www.reddit.com/r/
unixporn/comments/7iddwn/i3lock_faster_and_better_lockscreen/.

Command line syntax is

     wallpaper command [ commad arguments and options... ]

Commands encompass setting wallpaper (set), getting filename
of current wallpaper (getfilename), cycling thru wallpapers
in single directory, browsing thru wallpapers and applying
filters like blur, dimming, tinting, etc... (see below).
Vague future plans include automatic downloading of
wallpapers from specialized sites, extensive logging,
undo of all operations, taggig wallpapers, some interactive
way to change wallpaper in the minimalistic spirit of
dmenu, rofi, lemonbar and tint2.

RIGHT NOW, I concentrate on set command with syntax

     wallpaper set (filename|DEFAULT|CLIP)
                   [ (dim|blur|tint) [opt_arg] ...]

Special targets DEFAULT and CLIP are replaced with the built
in default wallpaper filename and content of clipboard,
respectively. Sets wallpaper to an image contained in
filename applying to it beforehand image filters specified
in optional

     image_recipe := ( filter_op [op_operand] ... )

If set command and filename is ommited, leaving only image
recipe, filters are applied to the current wallpaper image,
expanding command line effectively to

     wallpaper set $(wallpaper getfilename) image_recipe

Image filters are applied one by one, in the order specified
on the command line, with final modified image and all
intermediate results being stored in subdirectory .wall-cache
created in the same directory as the original image.
(I don't think this is the ideal place for cache; see
Q1 below for futher discussion.) 

------------------------------------------------
Q1: Is the right place for cache to be scattered throughout
the file system wherever there is some file that once served
as wallpaper?

In one implementation of cache, all modified images are
cached as

     /path/to/image/.wall-cache/image_filename__recipe        (1)

This has some advantages:

     - it is easy to implement, and

     - given filename in cache, it is easy to extract the
       original image filename and image recipe.

On the other hand,

     - wallpaper image might be in directory that is not
       writeable or even on read only medium,

     - with cache scattered throughout file system, it is
       much harder to, for example, empty the entire cache,
       than it is the case when whole cache is in centralized
       location.

     - all users using the same wallpaper share the same
       cache in that wallpaper's directory. This can be
       beneficial (you take advantage of modified image
       generated by another user) but can be a problem
       if different clients produce different images
       (say, have different defaults or different
       implementations for certain filters).

Alternative is to move cache to a centralized location, say
~/.wallpaper/cache/image and store modified image as

     ~/.wallpaper/cache/image/{sha1_hash}

where {sha1_hash} is SHA1 hash of string (1) above used in the
first implementation to avoid problems with encoding paths in
filenames. Since this new filename no longer contain the
name of original file, string (1) is additionaly recorded in
the file

     ~/.wallpaper/cache/refs/{sha1_hash}

for future reference.
